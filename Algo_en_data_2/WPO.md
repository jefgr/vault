# WPO 1
## Oefening 1
> Zie a-d/disjoint-sets/optimizedWPO1oef1.rkt

## Oefening 2
> Zie a-d/disjunct-sets/optimizedWPO1oef2.rkt

## Oefening 3
#TODO 

# WPO 2
## Oefening 1
### A:
> Zie a-d/graph/labeled/adjacency-list.rkt

### B:
> Bij een ijle graf is de adjacency-list efficienter voor geheugen gebruik en tijdgebruik valt wel mee
> Bij dense graf is de adjacency-matrix significant beter voor tijdgebruik

## Oefening 2
### A:
> We starten met elke node in zijn eigen set, daarna for-each boog een union doen, op einde controleren of alle nodes in dezelfde set zitten

### B:
> gerichte graffen, als je de verkeerde start positie neemt

### C:
> Zie: a-d/graph/unweighted/adjacency-matrix-wpo2.rkt

### D:
#TODO 
# WPO 4

## Oefening 1
> Zie 04-ongerichte-grafen/opgave/Vraag1-Tests.rkt 

## Oefening 2
> Zie 04-ongerichte-grafen/opgave/Vraag2-Tests.rkt 

Zit nog ergens een bug in idk

# WPO 5
## Oefening 2
> Zie 05-ongerichte-grafen/opgave/Vraag2.rkt

### part 2
Complexity
> O(|E|.log(|N|))

## Oefening 3

### part 3
> O((|E| + |V|) . log(|V|))

# WPO 6
## Oefening 1
> Zie 06-gerichte-grafen/opgave/Vraag1.rkt

## Oefening 2
> Zie 06-gerichte-grafen/opgave/Vraag2.rkt

## Oefening 3
#TODO Bekijk oefeningen nog

# WPO 7

> Zie 07-dynamisch-programmeren/opgave/value-iteration.rkt